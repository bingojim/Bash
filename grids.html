<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Color Grid Wallpaper Generator</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 0;
      padding: 0;
      background: #fff;
      text-align: center;
    }
    .header-content { 
      display: flex; 
      flex-direction: column; 
      align-items: center; 
      padding: 40px 10px 20px; 
    }
    .title-row { 
      display: flex; 
      align-items: center; 
      gap: 10px; 
      margin-bottom: 10px; 
    }
    .palette-icon { 
      font-size: 60px; 
    }
    .title { 
      font-family: 'Brush Script MT', cursive; 
      color: #4B0082; 
      font-size: 48px; 
      margin: 0; 
      font-weight: normal; 
    }
    .tagline-line1 { 
      color: #C71585; 
      font-size: 20px; 
    }
    .tagline-line2 { 
      color: #663399; 
      font-size: 16px; 
      margin-top: 20px; 
    }
    .common-btn {
      padding: 6px 12px;
      font-size: 14px;
      background-color: #6c63ff;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      width: 120px;
      transition: all 0.3s;
      position: relative;
      overflow: hidden;
    }
    .common-btn:hover { 
      background-color: #5a53d1; 
    }
    .common-btn:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }
    .common-btn.saving::after {
      content: "";
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
      animation: savingAnimation 1.5s infinite;
    }
    @keyframes savingAnimation {
      100% {
        left: 100%;
      }
    }
    .reset-btn {
      background-color: #ff6b6b;
    }
    .reset-btn:hover {
      background-color: #ff5252;
    }
    .file-instruction,
    .text-controls { 
      margin: 10px auto; 
      width: 90vw; 
      max-width: 500px; 
      display: flex; 
      justify-content: space-between; 
      align-items: center; 
    }
    .text-controls input { 
      flex: 1; 
      font-size: 14px; 
      padding: 6px; 
      margin-right: 10px; 
    }
    .key { 
      display: flex; 
      flex-wrap: wrap; 
      gap: 4px; 
      justify-content: center; 
      max-width: 90vw; 
      margin: 0 auto 10px; 
    }
    .key-box { 
      display: flex; 
      flex-direction: column; 
      align-items: center; 
      width: 32px; 
      margin: 5px; 
    }
    .key-box input[type="color"] { 
      width: 32px; 
      height: 32px; 
      border: none; 
      cursor: pointer; 
    }
    .key-box div { 
      font-size: 12px; 
      margin-top: 2px; 
    }
    .grid-container {
      width: 100%;
      overflow-x: auto;
      margin: 10px auto 20px;
    }
    .grid {
      display: grid;
      grid-template-columns: repeat(13, minmax(30px, 1fr));
      gap: 0;
      width: max-content;
      max-width: 90vw;
      margin: 0 auto;
    }
    .cell {
      aspect-ratio: 1;
      min-width: 30px;
      transition: background-color 0.3s;
      border: none;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
    }
    .toggle-screenshot-container {
      margin: 10px auto;
      width: 90vw;
      max-width: 500px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .button-container {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin: 20px 0;
      flex-wrap: wrap;
    }
    #instructionModal { 
      display: none; 
      position: fixed; 
      top: 0; 
      left: 0; 
      width: 100%; 
      height: 100%; 
      background: rgba(0,0,0,0.5); 
      justify-content: center; 
      align-items: center; 
      z-index: 1000;
    }
    #instructionModal .modal-content { 
      background: white; 
      padding: 20px; 
      border-radius: 8px; 
      max-width: 500px; 
      width: 90%; 
      text-align: left; 
      position: relative;
    }
    #instructionModal .close-btn { 
      position: absolute;
      top: 10px;
      right: 10px;
      background: none;
      border: none;
      font-size: 20px;
      cursor: pointer;
    }
    .save-status {
      font-size: 12px;
      color: #4CAF50;
      height: 16px;
      margin-top: 4px;
    }
  </style>
</head>
<body>
  <header class="header-content">
    <div class="title-row">
      <span class="palette-icon">ðŸŽ¨</span>
      <p class="title">Colour Grids</p>
    </div>
    <div class="tagline">
      <div class="tagline-line1">An Alphabet Colour Key</div>
      <div class="tagline-line2">Every letter gets a colour. Every word becomes a pattern. by Jimmy Rice</div>
    </div>
  </header>

  <div class="file-instruction">
    <input type="file" id="fileInput" accept=".txt" style="display:none">
    <button class="common-btn" onclick="document.getElementById('fileInput').click()">Choose File</button>
    <button class="common-btn" onclick="toggleInstructions()">Instructions</button>
    <button class="common-btn reset-btn" onclick="resetApplication()">Reset App</button>
  </div>

  <div class="text-controls">
    <input type="text" id="textInput" placeholder="Type or paste text here">
  </div>

  <div class="key" id="colorKey"></div>

  <div class="button-container">
    <button class="common-btn" onclick="randomizeKey()">Randomise</button>
    <button class="common-btn" onclick="generateShades()">Shades</button>
    <button class="common-btn" onclick="generateVibrantColors()">Vibrant</button>
    <button class="common-btn" onclick="generateComplementaryColors()">Complementary</button>
    <button class="common-btn" id="saveKeyBtn">Save Key</button>
  </div>

  <div class="toggle-screenshot-container">
    <button class="common-btn" onclick="toggleLetters()">Show/Hide Letters</button>
    <button class="common-btn" id="saveGridBtn">Save Grid</button>
  </div>
  <div class="save-status" id="saveStatus"></div>

  <div class="grid-container">
    <div class="grid" id="grid"></div>
  </div>

  <div id="instructionModal">
    <div class="modal-content">
      <button class="close-btn" onclick="toggleInstructions()">Ã—</button>
      <div class="title-row">
        <span class="palette-icon">ðŸŽ¨</span>
        <p class="title">Colour Grids</p>
      </div>
      <h2>Instructions</h2>
      <ol>
        <li>Type or paste text to generate a color grid</li>
        <li>Click color pickers to change individual letters</li>
        <li>Use "Randomise" for random colors</li>
        <li>Use "Shades" for monochromatic scheme</li>
        <li>Use "Vibrant" for bright, saturated colors</li>
        <li>Use "Complementary" for colors that complement the background</li>
        <li>Toggle letters visibility</li>
        <li>Click "Save Grid" to download your grid</li>
        <li>Click "Save Key" to save your current color scheme</li>
        <li>Use "Reset App" if anything stops working</li>
      </ol>
    </div>
  </div>

  <script>
    // Constants
    const alphabet = 'abcdefghijklmnopqrstuvwxyz'.split('');
    const GRID_SIZE = 13;
    const CELL_SIZE = 50;
    
    // State
    let keyColors = {};
    let lettersVisible = true;
    let gridData = Array(GRID_SIZE * GRID_SIZE).fill(" ");
    let saveOperations = {
      grid: { active: false, button: null },
      key: { active: false, button: null }
    };

    // Initialize the application
    function init() {
      // Initialize colors
      initializeColors();
      
      // Set up save operation buttons
      saveOperations.grid.button = document.getElementById('saveGridBtn');
      saveOperations.key.button = document.getElementById('saveKeyBtn');
      
      // Set up event listeners
      document.getElementById('fileInput').addEventListener('change', handleFileSelect);
      document.getElementById('textInput').addEventListener('input', debounce(generateFromText, 300));
      document.getElementById('saveGridBtn').addEventListener('click', () => handleSave('grid'));
      document.getElementById('saveKeyBtn').addEventListener('click', () => handleSave('key'));
      
      // Create UI
      createColorKey();
      renderGrid();
      
      // Initialize with "color grids" text
      generateGrid("color grids");
    }

    // Initialize color assignments
    function initializeColors() {
      alphabet.forEach(letter => {
        keyColors[letter] = getRandomColor();
      });
      keyColors[" "] = getRandomColor();
    }

    // Handle save operations
    function handleSave(type) {
      const operation = saveOperations[type];
      if (operation.active) return;
      
      operation.active = true;
      const button = operation.button;
      const originalText = button.textContent;
      
      button.disabled = true;
      button.classList.add('saving');
      button.textContent = "Saving...";
      
      const statusElement = document.getElementById('saveStatus');
      statusElement.textContent = '';
      
      // Clear any previous timeout
      if (operation.timeout) {
        clearTimeout(operation.timeout);
      }
      
      // Set timeout to reset button if operation takes too long
      operation.timeout = setTimeout(() => {
        if (operation.active) {
          resetSaveButton(operation, button, originalText);
          statusElement.textContent = 'Save timed out. Please try again.';
          statusElement.style.color = '#ff0000';
        }
      }, 5000);
      
      try {
        const savePromise = type === 'grid' ? saveGrid() : saveKey();
        
        savePromise.then(() => {
          clearTimeout(operation.timeout);
          operation.active = false;
          button.disabled = false;
          button.classList.remove('saving');
          button.textContent = originalText;
          statusElement.textContent = 'Saved successfully!';
          statusElement.style.color = '#4CAF50';
          
          // Clear success message after 3 seconds
          setTimeout(() => {
            if (statusElement.textContent === 'Saved successfully!') {
              statusElement.textContent = '';
            }
          }, 3000);
        }).catch(error => {
          console.error(`Error saving ${type}:`, error);
          clearTimeout(operation.timeout);
          resetSaveButton(operation, button, originalText);
          statusElement.textContent = 'Error saving. Please try again.';
          statusElement.style.color = '#ff0000';
        });
      } catch (error) {
        console.error(`Error in handleSave ${type}:`, error);
        clearTimeout(operation.timeout);
        resetSaveButton(operation, button, originalText);
        statusElement.textContent = 'Error saving. Please try again.';
        statusElement.style.color = '#ff0000';
      }
    }
    
    function resetSaveButton(operation, button, originalText) {
      operation.active = false;
      button.disabled = false;
      button.classList.remove('saving');
      button.textContent = originalText;
    }

    // Reset the entire application
    function resetApplication() {
      // Reset colors
      initializeColors();
      
      // Reset grid data
      gridData = Array(GRID_SIZE * GRID_SIZE).fill(" ");
      
      // Reset text input
      document.getElementById('textInput').value = "";
      
      // Reset save operations
      saveOperations.grid.active = false;
      saveOperations.key.active = false;
      
      // Reset button states
      const gridBtn = saveOperations.grid.button;
      const keyBtn = saveOperations.key.button;
      
      gridBtn.disabled = false;
      gridBtn.classList.remove('saving');
      gridBtn.textContent = "Save Grid";
      
      keyBtn.disabled = false;
      keyBtn.classList.remove('saving');
      keyBtn.textContent = "Save Key";
      
      // Clear status message
      document.getElementById('saveStatus').textContent = '';
      
      // Rebuild UI
      createColorKey();
      renderGrid();
      
      // Restore initial "color grids" text
      generateGrid("color grids");
      
      console.log("Application has been completely reset");
    }

    // File handling
    function handleFileSelect(event) {
      const file = event.target.files[0];
      if (!file) return;
      
      const reader = new FileReader();
      reader.onload = function(e) {
        generateGrid(e.target.result);
        event.target.value = '';
      };
      reader.readAsText(file);
    }
    
    // Color key creation
    function createColorKey() {
      const keyDiv = document.getElementById("colorKey");
      keyDiv.innerHTML = "";
      
      alphabet.forEach(letter => {
        const box = document.createElement("div");
        box.className = "key-box";
        
        const colorInput = document.createElement("input");
        colorInput.type = "color";
        colorInput.value = keyColors[letter];
        colorInput.oninput = () => {
          keyColors[letter] = colorInput.value;
          renderGrid();
        };
        
        const label = document.createElement("div");
        label.textContent = letter.toUpperCase();
        
        box.append(colorInput, label);
        keyDiv.appendChild(box);
      });
      
      // Add space character color picker
      const spaceBox = document.createElement("div");
      spaceBox.className = "key-box";
      
      const spaceInput = document.createElement("input");
      spaceInput.type = "color";
      spaceInput.id = "blankColor";
      spaceInput.value = keyColors[" "];
      spaceInput.oninput = () => {
        keyColors[" "] = spaceInput.value;
        renderGrid();
      };
      
      const spaceLabel = document.createElement("div");
      spaceLabel.textContent = "Space";
      
      spaceBox.append(spaceInput, spaceLabel);
      keyDiv.appendChild(spaceBox);
    }
    
    // Color scheme generators
    function randomizeKey() {
      alphabet.forEach(letter => {
        keyColors[letter] = getRandomColor();
      });
      keyColors[" "] = getRandomColor();
      document.getElementById("blankColor").value = keyColors[" "];
      createColorKey();
      renderGrid();
    }
    
    function generateShades() {
      const baseColor = getRandomColor();
      const r = parseInt(baseColor.substr(1, 2), 16);
      const g = parseInt(baseColor.substr(3, 2), 16);
      const b = parseInt(baseColor.substr(5, 2), 16);
      
      alphabet.forEach((letter, i) => {
        const factor = (i - 13) * 5;
        keyColors[letter] = rgbToHex(
          Math.max(0, Math.min(255, r + factor)),
          Math.max(0, Math.min(255, g + factor)),
          Math.max(0, Math.min(255, b + factor))
        );
      });
      
      keyColors[" "] = rgbToHex(
        Math.max(0, Math.min(255, r + 30)),
        Math.max(0, Math.min(255, g + 30)),
        Math.max(0, Math.min(255, b + 30))
      );
      document.getElementById("blankColor").value = keyColors[" "];
      
      createColorKey();
      renderGrid();
    }
    
    function generateVibrantColors() {
      const colorWheel = [0, 30, 60, 120, 180, 240, 270, 300, 330];
      const vibrantPalette = [];
      
      for (let i = 0; i < 26; i++) {
        const baseHue = colorWheel[i % colorWheel.length];
        const hueVariation = (Math.random() - 0.5) * 20;
        const hue = (baseHue + hueVariation + 360) % 360;
        const saturation = 85 + Math.random() * 15;
        const lightness = 50 + Math.random() * 20;
        vibrantPalette.push(hslToHex(hue, saturation, lightness));
      }
      
      // Shuffle the palette
      for (let i = vibrantPalette.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [vibrantPalette[i], vibrantPalette[j]] = [vibrantPalette[j], vibrantPalette[i]];
      }
      
      alphabet.forEach((letter, index) => {
        keyColors[letter] = vibrantPalette[index];
      });
      
      const randomBlankHue = Math.floor(Math.random() * 360);
      const blankColor = hslToHex(randomBlankHue, 80 + Math.random() * 20, 80 + Math.random() * 15);
      keyColors[" "] = blankColor;
      document.getElementById("blankColor").value = blankColor;
      
      createColorKey();
      renderGrid();
    }
    
    function generateComplementaryColors() {
      randomizeKey();
      
      const baseColor = keyColors[" "];
      const [h, s, l] = hexToHsl(baseColor);
      const complementaryHue = (h + 180) % 360;
      
      alphabet.forEach(letter => {
        const [currentH, currentS, currentL] = hexToHsl(keyColors[letter]);
        const ratio = 0.2 + (Math.random() * 0.6);
        const mixedH = (currentH * (1 - ratio) + complementaryHue * ratio) % 360;
        const mixedS = Math.min(100, currentS * 1.2);
        keyColors[letter] = hslToHex(mixedH, mixedS, currentL);
      });
      
      createColorKey();
      renderGrid();
    }
    
    // Save functions
    function saveGrid() {
      return new Promise((resolve, reject) => {
        try {
          const canvas = document.createElement("canvas");
          canvas.width = GRID_SIZE * CELL_SIZE;
          canvas.height = GRID_SIZE * CELL_SIZE;
          const ctx = canvas.getContext("2d");
          
          // Draw white background
          ctx.fillStyle = "white";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          
          // Draw grid cells
          for (let y = 0; y < GRID_SIZE; y++) {
            for (let x = 0; x < GRID_SIZE; x++) {
              const index = y * GRID_SIZE + x;
              const char = gridData[index] || " ";
              const color = keyColors[char.toLowerCase()] || keyColors[" "];
              ctx.fillStyle = color;
              ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
              
              if (lettersVisible && char !== " ") {
                ctx.fillStyle = getContrastColor(color);
                ctx.font = "bold 20px sans-serif";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(
                  char.toUpperCase(),
                  x * CELL_SIZE + CELL_SIZE / 2,
                  y * CELL_SIZE + CELL_SIZE / 2
                );
              }
            }
          }
          
          // Trigger download
          const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
          const filename = `color-grid-${timestamp}.png`;
          downloadCanvas(canvas, filename);
          
          resolve();
        } catch (error) {
          reject(error);
        }
      });
    }
    
    function saveKey() {
      return new Promise((resolve, reject) => {
        try {
          const keyDiv = document.getElementById("colorKey");
          const boxes = Array.from(keyDiv.querySelectorAll(".key-box"));
          
          // Canvas setup
          const BOX_SIZE = 64;
          const BOXES_PER_ROW = 5;
          const HORIZONTAL_GAP = 8;
          const VERTICAL_GAP = 16;
          const LABEL_HEIGHT = 24;
          const BORDER_SIZE = 10;
          
          const totalRows = Math.ceil(boxes.length / BOXES_PER_ROW);
          const canvasWidth = (BOX_SIZE + HORIZONTAL_GAP) * BOXES_PER_ROW + BORDER_SIZE * 2;
          const canvasHeight = (BOX_SIZE + LABEL_HEIGHT + VERTICAL_GAP) * totalRows + BORDER_SIZE * 2;
          
          const canvas = document.createElement("canvas");
          canvas.width = canvasWidth;
          canvas.height = canvasHeight;
          const ctx = canvas.getContext("2d");
          
          // Draw background
          ctx.fillStyle = "white";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          
          // Draw color boxes and labels
          boxes.forEach((box, index) => {
            const row = Math.floor(index / BOXES_PER_ROW);
            const col = index % BOXES_PER_ROW;
            const colorInput = box.querySelector("input[type='color']");
            const label = box.querySelector("div");
            
            const x = BORDER_SIZE + col * (BOX_SIZE + HORIZONTAL_GAP);
            const y = BORDER_SIZE + row * (BOX_SIZE + LABEL_HEIGHT + VERTICAL_GAP);
            
            // Draw color box
            ctx.fillStyle = colorInput.value;
            ctx.fillRect(x, y, BOX_SIZE, BOX_SIZE);
            
            // Draw label
            ctx.fillStyle = "#000000";
            ctx.font = "bold 16px sans-serif";
            ctx.textAlign = "center";
            ctx.textBaseline = "top";
            ctx.fillText(label.textContent, x + BOX_SIZE/2, y + BOX_SIZE + 4);
          });
          
          // Trigger download
          const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
          const filename = `color-key-${timestamp}.png`;
          downloadCanvas(canvas, filename);
          
          resolve();
        } catch (error) {
          reject(error);
        }
      });
    }
    
    // Helper function for canvas download
    function downloadCanvas(canvas, filename) {
      return new Promise((resolve, reject) => {
        try {
          const link = document.createElement("a");
          link.download = filename;
          link.href = canvas.toDataURL("image/png");
          document.body.appendChild(link);
          link.click();
          
          // Give some time for the download to initiate
          setTimeout(() => {
            document.body.removeChild(link);
            resolve();
          }, 100);
        } catch (error) {
          reject(error);
        }
      });
    }
    
    // Utility functions
    function getRandomColor() {
      return "#" + Math.floor(Math.random() * 16777215).toString(16).padStart(6, "0");
    }
    
    function getContrastColor(hexColor) {
      const r = parseInt(hexColor.substr(1, 2), 16);
      const g = parseInt(hexColor.substr(3, 2), 16);
      const b = parseInt(hexColor.substr(5, 2), 16);
      const brightness = (r * 299 + g * 587 + b * 114) / 1000;
      return brightness > 128 ? "#000000" : "#ffffff";
    }
    
    function debounce(func, delay) {
      let timeout;
      return function(...args) {
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(this, args), delay);
      };
    }
    
    function rgbToHex(r, g, b) {
      return "#" + [r, g, b].map(x => x.toString(16).padStart(2, "0")).join("");
    }
    
    function hslToHex(h, s, l) {
      h /= 360;
      s /= 100;
      l /= 100;
      
      let r, g, b;
      
      if (s === 0) {
        r = g = b = l;
      } else {
        const hue2rgb = (p, q, t) => {
          if (t < 0) t += 1;
          if (t > 1) t -= 1;
          if (t < 1/6) return p + (q - p) * 6 * t;
          if (t < 1/2) return q;
          if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
          return p;
        };
        
        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
      }
      
      const toHex = x => {
        const hex = Math.round(x * 255).toString(16);
        return hex.length === 1 ? '0' + hex : hex;
      };
      
      return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
    }
    
    function hexToHsl(hex) {
      const r = parseInt(hex.slice(1, 3), 16) / 255;
      const g = parseInt(hex.slice(3, 5), 16) / 255;
      const b = parseInt(hex.slice(5, 7), 16) / 255;
      
      const max = Math.max(r, g, b);
      const min = Math.min(r, g, b);
      let h, s, l = (max + min) / 2;
      
      if (max === min) {
        h = s = 0;
      } else {
        const d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        
        switch (max) {
          case r: h = (g - b) / d + (g < b ? 6 : 0); break;
          case g: h = (b - r) / d + 2; break;
          case b: h = (r - g) / d + 4; break;
        }
        
        h /= 6;
      }
      
      return [h * 360, s * 100, l * 100];
    }
    
    // Grid functions
    function toggleLetters() {
      lettersVisible = !lettersVisible;
      renderGrid();
    }
    
    function generateFromText() {
      const text = document.getElementById("textInput").value;
      generateGrid(text);
    }
    
    function generateGrid(text) {
      const cleanText = text.toLowerCase().replace(/[^a-z ]/g, "");
      gridData = Array(GRID_SIZE * GRID_SIZE).fill(" ");
      
      for (let i = 0; i < cleanText.length && i < GRID_SIZE * GRID_SIZE; i++) {
        gridData[i] = cleanText[i];
      }
      
      renderGrid();
    }
    
    function renderGrid() {
      const grid = document.getElementById("grid");
      grid.innerHTML = "";
      
      gridData.forEach((char, i) => {
        const cell = document.createElement("div");
        cell.className = "cell";
        cell.textContent = lettersVisible ? char.toUpperCase() : "";
        cell.style.backgroundColor = keyColors[char.toLowerCase()] || keyColors[" "];
        if (lettersVisible) {
          cell.style.color = getContrastColor(keyColors[char.toLowerCase()] || keyColors[" "]);
        }
        grid.appendChild(cell);
      });
    }
    
    function toggleInstructions() {
      const modal = document.getElementById("instructionModal");
      modal.style.display = modal.style.display === "flex" ? "none" : "flex";
    }
    
    // Initialize the application when the DOM is fully loaded
    window.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>