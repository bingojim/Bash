<!DOCTYPE html>
<html lang="en">

<!-- === START OF HEAD AND CSS SECTION === -->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Territory: The Aussie Game</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: Arial, sans-serif; background-color: #f0f0f0; min-height: 100vh; overflow-x: hidden; }
        .screen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #f0f0f0; display: flex; align-items: center; justify-content: center; padding: 10px; }
        .content-box { background: white; padding: 20px; border-radius: 15px; box-shadow: 0 4px 8px rgba(0,0,0,0.1); width: 100%; height: 98vh; margin: 0; display: flex; flex-direction: column; }
        .game-controls { display: flex; justify-content: center; align-items: flex-start; gap: 20px; margin: 20px 0; }
        .player-turn-panel { display: flex; flex-direction: column; gap: 10px; margin: 20px; width: 200px; }
        .player-turn-item { display: flex; align-items: center; padding: 10px; border-radius: 5px; background: rgba(255, 255, 255, 0.9); border: 2px solid #ccc; transition: all 0.3s ease; }
        .player-turn-item.active { background: #fff; border-color: #3498db; box-shadow: 0 0 10px rgba(52, 152, 219, 0.5); transform: scale(1.05); }
        .player-turn-item.eliminated { opacity: 0.6; background: #f0f0f0; border-color: #ccc; color: #666; }
        .player-emoji { font-size: 24px; margin-right: 10px; }
        .player-name { flex-grow: 1; }
        .animated-pieces { margin: 40px 0; }
       
        .piece-animation { 
            display: inline-block; 
            font-size: 48px; 
            animation: bounce 2s infinite; 
            margin: 0 20px; 
            text-shadow: 2px 2px 4px rgba(0,0,0,0.7); /* Add text shadow */
            font-weight: bold; /* Make emoji appear bolder */
        }

        .big-dice {
          font-size: 72px;
          margin: 20px 0;
          animation: popIn 0.5s ease-out;
        }

        .winner-result {
          background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
          border: 3px solid gold;
          box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }

        @keyframes bounce { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-20px); } }
        .piece-animation:nth-child(2) { animation-delay: 0.3s; }
        .piece-animation:nth-child(3) { animation-delay: 0.6s; }
         
.map-container {
    position: relative;
    width: 100%;
    flex-grow: 1;
    margin: 10px 0;
    border: 2px solid #ccc;
    border-radius: 10px;
    background-image: url('map of Australia with ct.png');
    background-size: contain;
    background-position: center;
    background-repeat: no-repeat;
    z-index: 0;
    /* Add this to maintain aspect ratio */
    max-height: 70vh;
    aspect-ratio: 1.5 / 1;
}

.state-marker {
    position: absolute;
    /* Change from fixed vw to responsive sizing */
    width: 8%;
    height: 0;
    padding-bottom: 8%;
    border-radius: 50%;
    background: rgba(255, 255, 255, 0.8);
    border: 3px solid #2c3e50;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    /* Change from fixed vw to responsive font size */
    font-size: 1.5vw;
    transform: translate(-50%, -50%);
    cursor: pointer;
    z-index: 1;
}

        .state-marker { position: absolute; width: 16vw; height: 16vw; border-radius: 50%; background: rgba(255, 255, 255, 0.8); border: 3px solid #2c3e50; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 3vw; transform: translate(-50%, -50%); cursor: pointer; z-index: 1; padding: 20px; }
        .state-marker::before { content: ''; position: absolute; width: 200%; height: 200%; left: -50%; top: -50%; border-radius: 50%; }
        .state-marker.valid-move::before { background: rgba(76, 175, 80, 0.1); border: 2px solid rgba(76, 175, 80, 0.3); }
        .state-marker.valid-move { background: rgba(232, 245, 233, 0.8); border-color: #4caf50; }
        

.game-piece {
    position: absolute;
    /* Change from fixed vw to responsive sizing */
    width: 4%;
    height: 0;
    padding-bottom: 4%;
    display: flex;
    align-items: center;
    justify-content: center;
    /* Change from fixed vw to responsive font size */
    font-size: 2vw;
    transition: all 0.3s ease;
    z-index: 3;
    cursor: pointer;
    border-radius: 50%;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
    font-weight: bold;
}

        .game-piece { 
            position: absolute; 
            width: 8vw; 
            height: 8vw; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            font-size: 4vw; 
            transition: all 0.3s ease; 
            z-index: 3; 
            cursor: pointer; 
            border-radius: 50%;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.7); /* Add text shadow to darken emoji */
            font-weight: bold; /* Make emoji appear bolder */
        }

        @keyframes buttonPulse {
          from { transform: scale(1); background-color: #e74c3c; }
          to { transform: scale(1.1); background-color: #c0392b; }
        }

        .team-1 { 
            background: #ff9a9a; /* Lighter red for Kangaroo */
            border: 2px solid #e74c3c; /* Darker red border */
        }
        .team-2 { 
            background: #8cc7f0; /* Lighter blue for Koala */
            border: 2px solid #2980b9; /* Darker blue border */
        }
        .team-3 { 
            background: #7aeb9c; /* Lighter green for Crocodile */
            border: 2px solid #27ae60; /* Darker green border */
        }

        .dice { width: 80px; height: 80px; background: white; border: 3px solid #2c3e50; border-radius: 12px; display: flex; align-items: center; justify-content: center; font-size: 48px; margin: 20px auto; cursor: pointer; }
        .dice.rolling { animation: roll 0.6s ease-out; }
        @keyframes roll { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        button { background: #3498db; color: white; border: none; padding: 12px 24px; border-radius: 5px; font-size: 16px; cursor: pointer; margin: 10px; }
        button:hover { background: #2980b9; }
        .player-input { margin: 15px 0; }
        .player-input input { padding: 10px; font-size: 16px; border: 2px solid #3498db; border-radius: 5px; width: 200px; }
        .piece-selection { display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; margin: 20px 0; }
        .piece-option { padding: 20px; border-radius: 10px; cursor: pointer; text-align: center; border: 3px solid #e0e0e0; }
        .piece-option:hover { border-color: #3498db; }
        .piece-option.disabled { opacity: 0.5; pointer-events: none; }

        /* Add these new CSS rules */
        .piece-preview {
            font-size: 36px;
            margin-bottom: 10px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
            font-weight: bold;
        }

        .banishment-announcement {
            z-index: 3000 !important;
            position: fixed;
            top: 5%;
            left: 0;
            right: 0;
            height: auto;
            background: rgba(0,0,0,0.8);
            display: flex;
            align-items: flex-start;
            justify-content: center;
        }

        .banishment-popup { background: white; padding: 40px; border-radius: 15px; text-align: center; animation: popIn 0.5s ease-out; max-width: 80%; }
        @keyframes popIn { 0% { transform: scale(0.5); opacity: 0; } 100% { transform: scale(1); opacity: 1; } }
        .subtle-button { 
            background-color: #87CEEB; /* Soft sky blue */
            color: white; 
            border: none; 
            padding: 8px 16px; 
            border-radius: 5px; 
            font-size: 14px; 
            cursor: pointer; 
            margin: 15px auto 5px auto; /* Added more top margin */
            display: block; 
            width: auto; 
        }
        .subtle-button:hover { 
            background-color: #5CACEE; /* Slightly darker sky blue on hover */
        }
        #closeRulesButton { 
            position: absolute; 
            right: 10px; 
            top: 10px; 
            background: #e74c3c; 
            width: 30px; 
            height: 30px; 
            border-radius: 50%; 
            font-weight: bold; 
            padding: 0;
        }
        #rulesModal { 
            display: none; 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            background: rgba(0,0,0,0.8); 
            z-index: 3000; 
        }
        #rulesModal > div { 
            background: white; 
            margin: 15% auto; 
            padding: 20px; 
            width: 80%; 
            max-width: 600px; 
            border-radius: 15px; 
            position: relative; 
        }
@keyframes buttonPulse {
  from { transform: scale(1); background-color: #e74c3c; }
  to { transform: scale(1.1); background-color: #c0392b; }
}

@keyframes winnerPulse {
  0% { transform: scale(1); opacity: 1; }
  50% { transform: scale(1.1); opacity: 0.9; }
  100% { transform: scale(1); opacity: 1; }
}

    </style>
</head>
<!-- === END OF HEAD AND CSS SECTION === -->
<!-- === START OF BODY AND HTML STRUCTURE === -->
<body>
    <div id="splashScreen" class="screen">
    <div class="content-box">
        <h1 style="
            font-family: 'Brush Script MT', cursive; 
            font-weight: normal; 
            font-size: 48px;
            color: #2c3e50;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.2);
        ">Territory: The Aussie Game</h1>
        <div class="animated-pieces">
            <span class="piece-animation">ü¶ò</span>
            <span class="piece-animation">üê®</span>
            <span class="piece-animation">üêä</span>
        </div>
        <button id="startButton">Start Game</button>
    </div>
</div>


    <div id="setupScreen" class="screen" style="display: none;">
        <div class="content-box">
            <h2>Enter Player Names</h2>
            <div class="player-input">
                <input type="text" id="player1Name" placeholder="Enter Your Name">
            </div>
            <div class="player-input">
                <input type="text" id="player2Name" placeholder="Player 2 Name (required for multiplayer)">
            </div>
            <div class="player-input">
                <input type="text" id="player3Name" placeholder="Player 3 or type 'game' for single player vs computer">
            </div>
            <button id="setupButton">Continue</button>
        </div>
    </div>

    <div id="rollOffScreen" class="screen" style="display: none;">
        <div class="content-box">
            <h2>Roll for Turn Order</h2>
            <p id="rollOffStatus">Ready to start roll-off</p>
            <div class="dice" id="rollOffDice">üé≤</div>
            <button id="rollOffButton">Roll Dice</button>
        </div>
    </div>

 <div id="pieceSelectionScreen" class="screen" style="display: none;">
    <div class="content-box">
        <h2>Choose Your Team</h2>
        <div id="pieceSelectionStatusContainer" style="
            background-color: #f8f9fa;
            border: 2px solid #3498db;
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
            text-align: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        ">
            <h3 id="pieceSelectionStatus" style="margin: 0; color: #2c3e50;"></h3>
            <div id="turnOrderDisplay" style="margin-top: 10px; font-size: 14px; color: #7f8c8d;"></div>
        </div>
        <div class="piece-selection">
            <div class="piece-option" data-team="1">
                <div class="piece-preview">ü¶ò</div>
                <div>Kangaroo Team</div>
            </div>
            <div class="piece-option" data-team="2">
                <div class="piece-preview">üê®</div>
                <div>Koala Team</div>
            </div>
            <div class="piece-option" data-team="3">
                <div class="piece-preview">üêä</div>
                <div>Crocodile Team</div>
            </div>
        </div>
    </div>
</div>



    <div id="gameBoard" class="screen" style="display: none;">
        <div class="content-box">
            <div class="game-controls">
                <div class="dice" id="gameDice">üé≤</div>
                <div class="player-turn-panel" id="playerTurnPanel"></div>
            </div>
            <button id="rollButton">Roll Dice</button>
            <div id="gameStatus" style="margin: 10px 0;"></div>
            <div class="map-container" id="mapContainer">
                <div class="state-marker" data-state="0" style="left: 66%; top: 73%;">VIC<br><small>Start</small></div>
                <div class="state-marker" data-state="1" style="left: 92.25%; top: 63%;">NSW</div>
                <div class="state-marker" data-state="2" style="left: 94.25%; top: 34.3%;">QLD</div>
                <div class="state-marker" data-state="3" style="left: 50.30%; top: 18%;">NT</div>
                <div class="state-marker" data-state="4" style="left: 12.6%; top: 44%;">WA</div>
                <div class="state-marker" data-state="5" style="left: 50.85%; top: 52.30%;">SA</div>
                <div class="state-marker" data-state="6" style="left: 86.9%; top: 87.5%;">TAS</div>
            </div>
            <button id="rulesButton" class="subtle-button">Instructions</button>

        </div>
    </div>
    
   <div id="rulesModal">
    <div>
        <h2>Territory: The Aussie Game - Instructions</h2>
        <button id="closeRulesButton">X</button>
        
        <div style="margin: 20px 0; line-height: 1.5;">
            <h3>Game Objective</h3>
            <p>
                The object of the game is to be the last player with pieces on the board by eliminating your opponents' pieces.
            </p>
            
            <h3>How to Play</h3>
            <ol style="text-align: left; padding-left: 20px;">
                <li>Players take turns rolling the dice and moving their pieces Anti-clockwise around Australia.</li>
                <li>When you roll, you must make exactly that many moves with your pieces.</li>
                <li>If you roll a 6, you make 6 moves and then roll again.</li>
                <li>You can only move to the next state in clockwise order.</li>
            </ol>
            
            <h3>Banishment & Fate</h3>
            <p>
                If you get two of your pieces on a state where an opponent has only one piece, their piece is banished to Tasmania.
                The banished player must press the Fate Button within 6 seconds to determine their outcome:
            </p>
            <ul style="text-align: left; padding-left: 20px;">
                <li>If fate is favorable, the piece returns to a random state on the mainland.</li>
                <li>If fate is unfavorable (or time runs out), the piece is eliminated from the game.</li>
            </ul>
            
            <h3>Winning the Game</h3>
            <p>
                When a player loses 2 pieces, they are eliminated from the game. The last player remaining wins!
            </p>
            
            <p style="margin-top: 15px; font-style: italic;">
                Have fun with player names - use favorite movie characters, historical figures, or anyone you like!
            </p>
        </div>
    </div>
</div>

<!-- === END OF BODY HTML STRUCTURE === -->
Here's Part 3 (beginning of JavaScript):
<!-- === START OF JAVASCRIPT === -->
<script>
// === START OF GAME INITIALIZATION AND VARIABLES ===
// === START OF GAME INITIALIZATION AND VARIABLES ===
let computerMoveTimeout = null;
let pieceSelectionInProgress = false;

let turnEndingInProgress = false;
let gameState;
let players = [];
let currentPlayer = 0;
let isRollOffInProgress = false;
let rollOffAttempts = 0;
const maxRollOffAttempts = 3;
let waitingForSecondRoll = false;
let movesRemaining = 0;
let originalPlayers = [];
let banishmentInProgress = false;
let twoPlayerModeActive = false;
let twoPlayerTurnCounter = 0;
// Keep track of active notifications
let activeNotifications = [];
let gameEnded = false;

function restartGame() {
    console.log("Restarting game...");
    window.location.reload();  // Use reload instead of href for a clean restart
}

// === START OF NOTIFICATION SYSTEM ===
function createNotificationArea() {
  // Check if notification area already exists
  if (document.getElementById('notification-area')) {
    return;
  }
  
  // Create notification area container
  const notificationArea = document.createElement('div');
  notificationArea.id = 'notification-area';
  notificationArea.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    background-color: transparent;
    z-index: 5000;
    display: flex;
    flex-direction: column;
    align-items: center;
    pointer-events: none; /* Allow clicks to pass through when empty */
  `;
  
  document.body.appendChild(notificationArea);
  
  // Add styles for notifications
  const styleElement = document.createElement('style');
  styleElement.textContent = `
    #notification-area {
      margin-bottom: 10px;
    }
    
    .game-notification {
      background: white;
      border-radius: 10px;
      padding: 15px 25px;
      margin: 10px;
      box-shadow: 0 4px 15px rgba(0,0,0,0.3);
      max-width: 80%;
      pointer-events: auto; /* Make the notification itself clickable */
      text-align: center;
    }
    
    /* Hide the old banishment announcements */
    .banishment-announcement {
      display: none !important;
    }
  `;
  document.head.appendChild(styleElement);
}

function showNotification(content, duration = 3000) {
  if (!document.getElementById('notification-area')) {
    createNotificationArea();
  }
  
  const notification = document.createElement('div');
  notification.className = 'game-notification';
  notification.innerHTML = content;
  
  const notificationArea = document.getElementById('notification-area');
  notificationArea.appendChild(notification);
  
  if (duration > 0) {
    setTimeout(() => {
      if (notification.parentNode) {
        notification.parentNode.removeChild(notification);
      }
    }, duration);
  }
  
  return notification;
}

function showGameNotification(message, duration) {
  console.log("Notification:", message);
  
  const notificationArea = document.getElementById('notification-area');
  if (notificationArea) {
      // Clear previous general notifications if needed
      const oldNotifications = notificationArea.querySelectorAll('.general-notification');
      oldNotifications.forEach(n => n.remove());
  }

  const notification = showNotification(`<p>${message}</p>`, duration || 2000);
  notification.classList.add('general-notification');
  
  return notification;
}

// === START OF GAME LOGIC CONTROLLERS ===

const GameState = {
  BANISHMENT_ANNOUNCEMENT: 'banishmentAnnouncement',
  CAPTIVE_ROLL: 'captiveRoll',
  CAPTOR_ROLL: 'captorRoll',
  RESOLVING_BANISHMENT: 'resolvingBanishment',
  RETURNING_PIECE: 'returningPiece'
};

const FateController = {
  fateAnnouncement: null,
  fateTimer: null,
  countdownInterval: null,
  timeRemaining: 6,

  initializeFateMechanism() {
    console.log("Initializing fate mechanism in notification area");
    
    const content = `
      <h2>üî• FATE BUTTON! üî•</h2>
      <p>${players[RollOffController.victimId].name} is banished to Tasmania!</p>
      <p>Press the button to decide your destiny!</p>
      <p class="countdown-warning">You have <span id="countdownDisplay">6</span> seconds to decide...</p>
      <button id="fateButton">Fate (6)</button>
    `;
    
    const notification = showNotification(content, 0);
    this.fateAnnouncement = notification;
    
    const style = document.createElement('style');
    style.textContent = `
      .countdown-warning { color: #e74c3c; font-weight: bold; margin-top: 10px; }
      #countdownDisplay { font-size: 1.2em; font-weight: bold; }
      #fateButton { font-size: 18px; padding: 12px 30px; background: #e74c3c; color: white; border: none; border-radius: 5px; cursor: pointer; margin-top: 15px; transition: all 0.3s ease; }
      #fateButton:hover { background: #c0392b; transform: scale(1.05); }
      @keyframes buttonPulse { from { transform: scale(1); background-color: #e74c3c; } to { transform: scale(1.1); background-color: #c0392b; } }
      .urgent { color: #ff0000; animation: textPulse 0.5s infinite alternate; }
      @keyframes textPulse { from { opacity: 1; } to { opacity: 0.7; } }
    `;
    document.head.appendChild(style);
    
    this.fateButton = notification.querySelector('#fateButton');
    this.fateButton.onclick = () => {
      clearTimeout(this.fateTimer);
      clearInterval(this.countdownInterval);
      this.determineFate(true);
    };
    
    const countdownDisplay = notification.querySelector('#countdownDisplay');
    this.timeRemaining = 6;
    
    setTimeout(() => {
      this.countdownInterval = setInterval(() => {
        this.timeRemaining--;
        if (countdownDisplay) countdownDisplay.textContent = this.timeRemaining;
        if (this.fateButton) this.fateButton.textContent = `Fate (${this.timeRemaining})`;
        
        if (this.timeRemaining <= 0) {
          clearInterval(this.countdownInterval);
          this.determineFate(false);
        } else if (this.timeRemaining <= 3) {
          if (this.fateButton) this.fateButton.style.animation = "buttonPulse 0.5s infinite alternate";
          if (countdownDisplay) countdownDisplay.classList.add('urgent');
        }
      }, 1000);
    }, 2000);
    
    this.fateTimer = setTimeout(() => this.determineFate(false), 8000);
    
    if (players[RollOffController.victimId].isComputer) {
      setTimeout(() => {
        if (this.fateButton) this.fateButton.click();
      }, 2000);
    }
  },

  determineFate(pressed) {
    console.log(`Determining fate: button pressed = ${pressed}`);
    if (pressed) {
      const fate = Math.random() < 0.5;
      if (fate) {
        showGameNotification("Return!!!", 3000);
        this.cleanup();
        RollOffController.transition(GameState.RETURNING_PIECE);
      } else {
        showGameNotification("You are eliminated!", 4000);
        this.cleanup();
        RollOffController.eliminatePiece();
      }
    } else {
      showGameNotification("Time's up! You are eliminated", 4000);
      this.cleanup();
      RollOffController.eliminatePiece();
    }
  },

  cleanup() {
    console.log("Cleaning up fate controller");
    if (this.countdownInterval) clearInterval(this.countdownInterval);
    if (this.fateTimer) clearTimeout(this.fateTimer);
    if (this.fateAnnouncement && this.fateAnnouncement.parentNode) {
        this.fateAnnouncement.parentNode.removeChild(this.fateAnnouncement);
    }
    this.fateAnnouncement = null; // Reset the announcement reference
    this.fateTimer = null;
    this.countdownInterval = null;
}
}
;

const RollOffController = {
  currentState: null,
  captivePiece: null,
  captorId: null,
  victimId: null,
  captiveRoll: 0,
  captorRoll: 0,
  callback: null,
  fateInitTimeout: null, // Add this line
  
  startBanishment(piece, captorId, victimId, callback) {
    console.log(`Starting banishment: captorId=${captorId}, victimId=${victimId}`);
    this.captivePiece = piece;
    this.captorId = captorId;
    this.victimId = victimId;
    this.callback = callback;
    this.captiveRoll = 0;
    this.captorRoll = 0;
    this.transition(GameState.BANISHMENT_ANNOUNCEMENT);
  },
  
  transition(newState) {
    console.log(`Roll-off transitioning from ${this.currentState} to ${newState}`);
    this.currentState = newState;
    
    switch(newState) {
      case GameState.BANISHMENT_ANNOUNCEMENT: this.showBanishmentAnnouncement(); break;
      case GameState.CAPTIVE_ROLL: this.setupCaptiveRoll(); break;
      case GameState.CAPTOR_ROLL: this.setupCaptorRoll(); break;
      case GameState.RESOLVING_BANISHMENT: this.resolveBanishment(); break;
      case GameState.RETURNING_PIECE: this.returnPiece(); break;
    }
  },
  
  showBanishmentAnnouncement() {
    const content = `<h2>üé≤ Banishment! üé≤</h2><p>${players[this.victimId].name} is banished to Tasmania. Fate will decide your outcome!</p>`;
    const notification = showNotification(content, 4000);
    
    this.captivePiece.position = 6;
    movePieceToState(this.captivePiece, 6);
    
    // Only set up one timeout to initialize the fate mechanism
    if (this.fateInitTimeout) {
        clearTimeout(this.fateInitTimeout);
    }
    
    this.fateInitTimeout = setTimeout(() => {
        if (notification.parentNode) notification.parentNode.removeChild(notification);
        FateController.initializeFateMechanism();
    }, 4000);
  },

  displayRollResult(playerName, roll, isWinner) {
    const resultEmoji = isWinner ? 'üèÜ' : 'üé≤';
    const content = `<h3>${resultEmoji} Roll Result ${resultEmoji}</h3><p>${playerName} rolled:</p><div class="big-dice">${['‚öÄ','‚öÅ','‚öÇ','‚öÉ','‚öÑ','‚öÖ'][roll-1]}</div><p>${isWinner ? 'That\'s a winning roll!' : ''}</p>`;
    showNotification(content, 3000);
  },
  
  setupCaptiveRoll() {
    updateGameStatus(`ROLL-OFF: ${players[this.victimId].name} (captive) to roll`);
    const rollButton = document.getElementById('rollButton');
    
    rollButton.onclick = () => {
      this.captiveRoll = this.performRoll();
      setTimeout(() => {
        this.displayRollResult(players[this.victimId].name, this.captiveRoll, false);
        setTimeout(() => this.transition(GameState.CAPTOR_ROLL), 1800);
      }, 700);
    };
    
    if (players[this.victimId].isComputer) {
      setTimeout(() => { if (this.currentState === GameState.CAPTIVE_ROLL) rollButton.onclick(); }, 1500);
    }
  },
  
  setupCaptorRoll() {
    updateGameStatus(`ROLL-OFF: ${players[this.captorId].name} (captor) to roll`);
    const rollButton = document.getElementById('rollButton');
    
    rollButton.onclick = () => {
      this.captorRoll = this.performRoll();
      const captorWins = this.captorRoll > this.captiveRoll;
      const isTie = this.captorRoll === this.captiveRoll;
      
      setTimeout(() => {
        this.displayRollResult(players[this.captorId].name, this.captorRoll, !isTie && captorWins);
        setTimeout(() => this.transition(GameState.RESOLVING_BANISHMENT), 1800);
      }, 700);
    };
    
    if (players[this.captorId].isComputer) {
      setTimeout(() => { if (this.currentState === GameState.CAPTOR_ROLL) rollButton.onclick(); }, 1500);
    }
  },
  
  performRoll() {
    const dice = document.getElementById('gameDice');
    dice.classList.add('rolling');
    const roll = Math.floor(Math.random() * 6) + 1;
    setTimeout(() => {
      dice.classList.remove('rolling');
      dice.textContent = ['‚öÄ','‚öÅ','‚öÇ','‚öÉ','‚öÑ','‚öÖ'][roll-1];
    }, 600);
    return roll;
  },
  
  resolveBanishment() {
    if (this.captiveRoll === this.captorRoll) {
      showGameNotification("Tie! Roll again!", 3000);
      this.transition(GameState.CAPTIVE_ROLL);
      return;
    }
    if (this.captiveRoll > this.captorRoll) {
      showGameNotification(`${players[this.victimId].name} rolled higher and escapes! Rolling for return position...`, 4000);
      this.transition(GameState.RETURNING_PIECE);
    } else {
      showGameNotification(`${players[this.captorId].name} rolled higher! ${players[this.victimId].name}'s piece is eliminated!`, 4000);
      this.eliminatePiece();
    }
  },
  
  returnPiece() {
    const returnRoll = Math.floor(Math.random() * 6);
    this.captivePiece.position = returnRoll;
    this.captivePiece.isOnBoard = true; // Added this line
    movePieceToState(this.captivePiece, returnRoll);
    showGameNotification(`Piece returns to ${getStateName(returnRoll)}!`, 3000);
    if (!this.checkForImmediateBanishment(returnRoll)) {
      this.finishRollOff();
    }
  },
  
  eliminatePiece() {
    showGameNotification(`${players[this.victimId].name}'s piece has been eliminated!`, 4000);
    this.captivePiece.element.style.display = 'none';
    this.captivePiece.position = -1;
    this.captivePiece.isOnBoard = false;
    players[this.victimId].eliminatedPieces++;
    if (players[this.victimId].eliminatedPieces >= 2) {
      eliminatePlayer(this.victimId);
    }
    this.finishRollOff();
  },
  
  checkForImmediateBanishment(stateIndex) {
    const otherPiecesInState = getPiecesInState(stateIndex).filter(p => p !== this.captivePiece);
    const playerCounts = new Map();
    otherPiecesInState.forEach(p => {
      const playerIndex = players.findIndex(player => player.pieces.includes(p));
      if (!playerCounts.has(playerIndex)) playerCounts.set(playerIndex, []);
      playerCounts.get(playerIndex).push(p);
    });
    
    let shouldBeBanished = false;
    let newCaptorId = null;
    playerCounts.forEach((pieces, potentialCaptorId) => {
      if (potentialCaptorId !== this.victimId && pieces.length >= 2) {
        shouldBeBanished = true;
        newCaptorId = potentialCaptorId;
      }
    });
    
    if (shouldBeBanished) {
      console.log(`Piece returned to ${getStateName(stateIndex)} but is being banished again`);
      setTimeout(() => RollOffController.startBanishment(this.captivePiece, newCaptorId, this.victimId, this.callback), 1000);
      return true;
    }
    return false;
  },
  
  finishRollOff() {
    console.log("Finishing roll-off process");
    document.getElementById('rollButton').onclick = handleGameDiceRoll;
    banishmentInProgress = false;
    
    // Clear any pending fate initialization
    if (this.fateInitTimeout) {
        clearTimeout(this.fateInitTimeout);
        this.fateInitTimeout = null;
    }
    
    if (this.callback) {
      console.log("Calling roll-off callback");
      setTimeout(() => this.callback(), 500);
    }
    this.currentState = null;
  }
};


// === START OF EVENT HANDLERS AND SETUP ===
document.getElementById('setupButton').onclick = startRollOff;
document.getElementById('rollOffButton').onclick = handleRollOff;
document.getElementById('rollButton').onclick = handleGameDiceRoll;
document.getElementById('rulesButton').onclick = () => document.getElementById('rulesModal').style.display = 'block';
document.getElementById('closeRulesButton').onclick = () => document.getElementById('rulesModal').style.display = 'none';
document.getElementById('startButton').onclick = () => {
    document.getElementById('splashScreen').style.display = 'none';
    document.getElementById('setupScreen').style.display = 'flex';
};

document.querySelectorAll('.state-marker').forEach(marker => marker.onclick = handleStateClick);
document.querySelectorAll('.piece-option').forEach(option => option.onclick = handlePieceSelection);

// === START OF GAME SETUP AND ROLL-OFF FUNCTIONS ===
function startRollOff() {
    const p1Name = document.getElementById('player1Name').value.trim();
    const p2Name = document.getElementById('player2Name').value.trim();
    const p3Name = document.getElementById('player3Name').value.trim();

    // Check for single player vs computer mode with custom name
    if (p1Name && !p2Name && p3Name && p3Name.toLowerCase().startsWith('game')) {
        // Check if there's a custom name after "game-"
        let computerName = 'Computer';
        if (p3Name.toLowerCase().startsWith('game-') && p3Name.length > 5) {
            computerName = p3Name.substring(5); // Extract name after "game-"
        }
        
        players = [
            {
                name: p1Name,
                pieces: [],
                roll: 0,
                team: null,
                emoji: null,
                piecesInPlay: 0,
                eliminatedPieces: 0
            },
            {
                name: computerName,
                pieces: [],
                roll: 0,
                team: null,
                emoji: null,
                piecesInPlay: 0,
                eliminatedPieces: 0,
                isComputer: true
            }
        ];
    }
    // Original multiplayer check
    else if (!p1Name || !p2Name) {
        alert('For multiplayer: Enter at least 2 player names\nFor single player: Enter your name and type "game" in Player 3');
        return;
    }
    // Original multiplayer setup
    else {
        players = [
            {
                name: p1Name,
                pieces: [],
                roll: 0,
                team: null,
                emoji: null,
                piecesInPlay: 0,
                eliminatedPieces: 0
            },
            {
                name: p2Name,
                pieces: [],
                roll: 0,
                team: null,
                emoji: null,
                piecesInPlay: 0,
                eliminatedPieces: 0
            }
        ];

        if (p3Name) {
            // Check if third player should be computer with custom name
            let isGameOpponent = p3Name.toLowerCase() === 'game';
            let computerName = 'Computer';
            
            if (p3Name.toLowerCase().startsWith('game-') && p3Name.length > 5) {
                isGameOpponent = true;
                computerName = p3Name.substring(5); // Extract name after "game-"
            }
            
            players.push({
                name: isGameOpponent ? computerName : p3Name,
                pieces: [],
                roll: 0,
                team: null,
                emoji: null,
                piecesInPlay: 0,
                eliminatedPieces: 0,
                isComputer: isGameOpponent
            });
        }
    }

    currentPlayer = 0;
    rollOffAttempts = 0;
    originalPlayers = [...players];
    
    document.getElementById('setupScreen').style.display = 'none';
    document.getElementById('rollOffScreen').style.display = 'flex';
    updateRollOffStatus(`${players[0].name} - Roll for turn order!`);
}


function handleRollOff() {
    if (currentPlayer >= players.length || players[currentPlayer].roll !== 0) return;
    
    const dice = document.getElementById('rollOffDice');
    dice.classList.add('rolling');
    
    setTimeout(() => {
        const roll = Math.floor(Math.random() * 6) + 1;
        dice.classList.remove('rolling');
        dice.textContent = ['‚öÄ','‚öÅ','‚öÇ','‚öÉ','‚öÑ','‚öÖ'][roll-1];
        players[currentPlayer].roll = roll;
        updateRollOffStatus(`${players[currentPlayer].name} rolled ${roll}!`);
        
        if (currentPlayer < players.length - 1) {
            currentPlayer++;
            setTimeout(() => {
                if (players[currentPlayer].isComputer) handleRollOff();
                else updateRollOffStatus(`${players[currentPlayer].name} - Roll for turn order!`);
            }, 1000);
        } else {
            if (originalPlayers.length > 0 && originalPlayers.length !== players.length) {
                setTimeout(() => {
                    players.sort((a, b) => b.roll - a.roll);
                    const nonTiedPlayers = originalPlayers.filter(op => !players.some(tp => tp.name === op.name));
                    players = [...players, ...nonTiedPlayers];
                    finishRollOff();
                }, 1000);
            } else {
                setTimeout(checkRollOffResults, 1000);
            }
        }
    }, 600);
}

function checkRollOffResults() {
    const rolls = players.map(p => p.roll);
    const maxRoll = Math.max(...rolls);
    const tiedPlayers = players.filter(p => p.roll === maxRoll);
    const otherPlayers = players.filter(p => p.roll < maxRoll).sort((a, b) => b.roll - a.roll);
    
    if (tiedPlayers.length > 1) {
        rollOffAttempts++;
        if (rollOffAttempts < maxRollOffAttempts) {
            if (originalPlayers.length === 0) originalPlayers = JSON.parse(JSON.stringify(players));
            players = [...tiedPlayers];
            players.forEach(p => p.roll = 0);
            currentPlayer = 0;
            updateRollOffStatus('Tie! Rolling again between tied players...');
            setTimeout(() => {
                if (players[currentPlayer].isComputer) handleRollOff();
                else updateRollOffStatus(`${players[currentPlayer].name} - Roll again!`);
            }, 1000);
        } else {
            const randomizedTied = tiedPlayers.sort(() => Math.random() - 0.5);
            players = [...randomizedTied, ...otherPlayers];
            finishRollOff();
        }
    } else {
        players = [...tiedPlayers, ...otherPlayers];
        finishRollOff();
    }
}

function finishRollOff() {
    if (originalPlayers.length > 0) {
        const playerOrder = players.map(p => p.name);
        players = JSON.parse(JSON.stringify(originalPlayers));
        players.sort((a, b) => playerOrder.indexOf(a.name) - playerOrder.indexOf(b.name));
    }
    players.forEach((player, index) => player.team = index + 1);
    let message = 'Final Turn Order:\n' + players.map((p, i) => `${i + 1}. ${p.name}`).join('\n');
    if (rollOffAttempts >= maxRollOffAttempts) message += '\n(Positions assigned randomly after maximum tie-breaks)';
    updateRollOffStatus(message);
    setTimeout(startPieceSelection, 2000);
}

function updateRollOffStatus(message) {
    document.getElementById('rollOffStatus').textContent = message;
}

// === START OF PIECE SELECTION AND GAME INITIALIZATION ===
function startPieceSelection() {
    document.getElementById('rollOffScreen').style.display = 'none';
    document.getElementById('pieceSelectionScreen').style.display = 'flex';
    currentPlayer = 0;
    pieceSelectionInProgress = false;
    
    // Reset all piece options
    document.querySelectorAll('.piece-option').forEach(option => {
        option.classList.remove('disabled');
        
        // Add direct click handler
        option.onclick = function(event) {
            console.log("Direct click handler called");
            handlePieceSelection(event);
        };
    });
    
    // Show the turn order before starting selection
    let turnOrderMessage = "Selection Order: ";
    players.forEach((player, index) => {
        if (index > 0) turnOrderMessage += " ‚Üí ";
        turnOrderMessage += player.name;
    });
    
    // Create notification area if needed
    createNotificationArea();
    
    // Show turn order notification
    showGameNotification(turnOrderMessage, 4000);
    
    // Update the selection status after a delay
    setTimeout(() => {
        updatePieceSelectionStatus();
        
        // Handle computer player if they go first
        if (players[currentPlayer].isComputer) {
            computerSelectPiece();
        }
    }, 1000);
    
    // Re-attach event handlers to piece options
    setTimeout(() => {
        document.querySelectorAll('.piece-option').forEach(option => {
            option.onclick = handlePieceSelection;
        });
        console.log("Piece selection event handlers attached");
    }, 500);
}


function updatePieceSelectionStatus() {
    // Get the status element
    const statusElement = document.getElementById('pieceSelectionStatus');
    const turnOrderElement = document.getElementById('turnOrderDisplay');
    
    // Create turn order text
    let turnOrderText = "Turn Order: ";
    players.forEach((player, index) => {
        if (index > 0) turnOrderText += " ‚Üí ";
        
        // Highlight current player in the turn order
        if (index === currentPlayer) {
            turnOrderText += `<strong style="color: #e74c3c;">${player.name}</strong>`;
        } else if (index < currentPlayer) {
            turnOrderText += `<span style="text-decoration: line-through;">${player.name}</span>`;
        } else {
            turnOrderText += player.name;
        }
    });
    
    // Update the turn order display
    turnOrderElement.innerHTML = turnOrderText;
    
    // Create a prominent message for the current player
    statusElement.innerHTML = `<span style="font-size: 1.2em; color: #e74c3c;">${players[currentPlayer].name}</span>, choose your team!`;
    
    // Add visual emphasis with animation
    statusElement.style.animation = "none";
    setTimeout(() => {
        statusElement.style.animation = "highlight 1s ease-in-out";
    }, 10);
    
    // Add the highlight animation if it doesn't exist
    if (!document.getElementById('highlightAnimation')) {
        const style = document.createElement('style');
        style.id = 'highlightAnimation';
        style.textContent = `
            @keyframes highlight {
                0% { transform: scale(1); }
                50% { transform: scale(1.05); }
                100% { transform: scale(1); }
            }
        `;
        document.head.appendChild(style);
    }
}

function handlePieceSelection(event) {
    // Prevent selection if already in progress
    if (pieceSelectionInProgress) {
        console.log("Selection already in progress, ignoring click");
        return;
    }
    
    const option = event.currentTarget;
    
    // Ignore disabled options
    if (option.classList.contains('disabled')) {
        console.log("Option already selected, ignoring");
        return;
    }
    
    console.log(`Player ${currentPlayer} (${players[currentPlayer].name}) selecting team`);
    pieceSelectionInProgress = true;
    
    // Get the selected team
    const selectedTeam = option.dataset.team;
    const selectedEmoji = option.querySelector('.piece-preview').textContent;
    
    // Update player's team and emoji
    players[currentPlayer].emoji = selectedEmoji;
    players[currentPlayer].team = parseInt(selectedTeam);
    
    // Disable the selected option
    option.classList.add('disabled');
    
    // Show selection confirmation
    showGameNotification(`${players[currentPlayer].name} selected the ${getTeamName(selectedTeam)} team!`, 2000);
    
    // Check if there are more players to select
    if (currentPlayer < players.length - 1) {
        // Move to next player with a delay
        setTimeout(() => {
            currentPlayer++;
            updatePieceSelectionStatus();
            pieceSelectionInProgress = false;
            
            // Handle computer player selection with delay
            if (players[currentPlayer].isComputer) {
                computerSelectPiece();
            }
        }, 1500);
    } else {
        // All players have selected, start the game after a delay
        setTimeout(() => {
            pieceSelectionInProgress = false;
            startGame();
        }, 2000);
    }
}

function computerSelectPiece() {
    console.log(`Computer player ${currentPlayer} (${players[currentPlayer].name}) selecting`);
    pieceSelectionInProgress = true;
    
    // Show notification before computer selects
    showGameNotification(`${players[currentPlayer].name} is selecting a team...`, 1500);
    
    setTimeout(() => {
        const availableOptions = Array.from(document.querySelectorAll('.piece-option:not(.disabled)'));
        if (availableOptions.length > 0) {
            // Get the first available option
            const computerChoice = availableOptions[0];
            const selectedTeam = computerChoice.dataset.team;
            const selectedEmoji = computerChoice.querySelector('.piece-preview').textContent;
            
            // Update computer's team and emoji
            players[currentPlayer].emoji = selectedEmoji;
            players[currentPlayer].team = parseInt(selectedTeam);
            
            // Disable the selected option
            computerChoice.classList.add('disabled');
            
            // Show selection confirmation
            showGameNotification(`${players[currentPlayer].name} selected the ${getTeamName(selectedTeam)} team!`, 2000);
            
            // Move to next player or start game
            setTimeout(() => {
                if (currentPlayer < players.length - 1) {
                    currentPlayer++;
                    updatePieceSelectionStatus();
                    pieceSelectionInProgress = false;
                    
                    if (players[currentPlayer].isComputer) {
                        computerSelectPiece();
                    }
                } else {
                    // All players have selected, start the game
                    pieceSelectionInProgress = false;
                    startGame();
                }
            }, 1500);
        } else {
            console.error("No available options for computer");
            pieceSelectionInProgress = false;
        }
    }, 2000);
}

function getTeamName(teamNumber) {
    const teamNames = {
        "1": "Kangaroo",
        "2": "Koala",
        "3": "Crocodile"
    };
    return teamNames[teamNumber] || "Unknown";
}



// === START OF GAME MECHANICS AND MOVEMENT FUNCTIONS ===
function startGame() {
    document.getElementById('pieceSelectionScreen').style.display = 'none';
    document.getElementById('gameBoard').style.display = 'flex';
    gameState = 'initial';
    currentPlayer = 0;
    initializeGamePieces();
    updateGameStatus(`${players[currentPlayer].name}'s turn - Roll the dice`);
    updateTurnDisplay();
    createNotificationArea();
    if (players[currentPlayer].isComputer) {
        console.log("Computer goes first - scheduling initial roll");
        setTimeout(() => { if (!banishmentInProgress && !turnEndingInProgress) handleGameDiceRoll(); }, 1500);
    }
}

function initializeGamePieces() {
    const startMarker = document.querySelector('[data-state="0"]');
    const container = document.querySelector('.map-container');
    const containerRect = container.getBoundingClientRect();
    const markerRect = startMarker.getBoundingClientRect();
    const baseLeft = ((markerRect.left - containerRect.left) / containerRect.width * 100);
    const baseTop = ((markerRect.top - containerRect.top) / containerRect.height * 100);
    
    players.forEach((player, playerIndex) => {
        for (let i = 0; i < 3; i++) {
            const piece = document.createElement('div');
            piece.className = `game-piece team-${player.team}`;
            piece.textContent = player.emoji;
            const angle = (playerIndex * 120 + i * 40) * (Math.PI / 180);
            const radius = 4;
            const offsetX = Math.cos(angle) * radius;
            const offsetY = Math.sin(angle) * radius;
            piece.style.left = `${baseLeft + offsetX}%`;
            piece.style.top = `${baseTop + offsetY}%`;
            piece.style.display = 'flex';
            piece.style.zIndex = 3 + playerIndex * 3 + i;
            container.appendChild(piece);
            player.pieces.push({ element: piece, position: 0, isOnBoard: true, index: i });
        }
        player.piecesInPlay = 3;
    });
}

function handleGameDiceRoll() {
    if (movesRemaining > 0 || banishmentInProgress || turnEndingInProgress) return;
    
    const dice = document.getElementById('gameDice');
    dice.classList.add('rolling');
    
    setTimeout(() => {
        const roll = Math.floor(Math.random() * 6) + 1;
        dice.classList.remove('rolling');
        dice.textContent = ['‚öÄ','‚öÅ','‚öÇ','‚öÉ','‚öÑ','‚öÖ'][roll-1];
        movesRemaining = roll;
        
        if (roll === 6) {
            waitingForSecondRoll = true;
            updateGameStatus(`${players[currentPlayer].name} rolled a 6! Make ${roll} moves, then roll again!`);
        } else {
            updateGameStatus(`${players[currentPlayer].name} rolled ${roll} - ${roll} moves remaining`);
        }
        highlightValidMoves();

        if (players[currentPlayer].isComputer) {
            setTimeout(() => { if (!banishmentInProgress) makeComputerMove(); }, 1000);
        }
    }, 600);
}

function handleSecondRoll() {
    waitingForSecondRoll = false;
    updateGameStatus(`${players[currentPlayer].name} completed 6 moves. Roll again!`);
}

function handleStateClick(event) {
    if (movesRemaining <= 0 || players[currentPlayer].isComputer || banishmentInProgress) return;
    
    const targetState = parseInt(event.currentTarget.dataset.state);
    if (targetState === 6) return;

    const player = players[currentPlayer];
    let moved = false;
    
    if (player.pieces.some(p => p.isOnBoard)) {
        const validPiece = player.pieces.find(p => p.isOnBoard && (p.position + 1) % 6 === targetState);
        if (validPiece) {
            movePieceToState(validPiece, targetState);
            validPiece.position = targetState;
            moved = true;
        }
    }

    if (moved) {
        movesRemaining--;
        if (movesRemaining === 0) {
            if (waitingForSecondRoll) handleSecondRoll();
            else {
                // Only check for banishment once, then end turn if no banishments found
                const banishmentsFound = checkForBanishment();
                if (!banishmentsFound) {
                    endTurn();
                }
            }
        }
        updateGameStatus(`${player.name}: ${movesRemaining} moves remaining`);
        highlightValidMoves();
    }
}

function movePieceToState(piece, stateIndex) {
    const marker = document.querySelector(`[data-state="${stateIndex}"]`);
    const container = document.querySelector('.map-container');
    const containerRect = container.getBoundingClientRect();
    const markerRect = marker.getBoundingClientRect();
    
    const leftPercent = ((markerRect.left - containerRect.left) / containerRect.width * 100);
    const topPercent = ((markerRect.top - containerRect.top) / containerRect.height * 100);
    
    // Special positioning for Tasmania (stateIndex 6)
    if (stateIndex === 6) {
        // Move pieces to the middle of Tasmania, further down from Victoria
        const tasmaniaLeftPercent = 86.9;
        const tasmaniaTopPercent = 80; // Moved down further
        
        const piecesInTasmania = getPiecesInState(6).filter(p => p !== piece);
        const pieceCount = piecesInTasmania.length;
        
        // Create a tighter formation in Tasmania
        const angle = (pieceCount * 60) * (Math.PI / 180); // 60-degree spacing
        const radius = 2.5; // Smaller radius for tighter grouping
        
        const offsetX = Math.cos(angle) * radius;
        const offsetY = Math.sin(angle) * radius;
        
        piece.element.style.left = `${tasmaniaLeftPercent + offsetX}%`;
        piece.element.style.top = `${tasmaniaTopPercent + offsetY}%`;
    } else {
        // Tighter positioning for other states
        const piecesInState = getPiecesInState(stateIndex).filter(p => p !== piece);
        const pieceCount = piecesInState.length;
        
        const playerIndex = players.findIndex(player => player.pieces.includes(piece));
        const pieceIndex = players[playerIndex].pieces.indexOf(piece);
        
        // Create a tighter formation based on player index and piece index
        const baseAngle = (playerIndex * 120);
        const angleOffset = pieceIndex * 30; // Reduced from 40 to 30 for tighter grouping
        const spiralFactor = Math.floor(pieceCount / 4) + 1; // Adjusted divisor for tighter spiral
        const angle = (baseAngle + angleOffset) * (Math.PI / 180);
        const radius = 4 * spiralFactor; // Reduced from 6 to 4 for tighter grouping
        
        const offsetX = Math.cos(angle) * radius;
        const offsetY = Math.sin(angle) * radius;
        
        piece.element.style.left = `${leftPercent + offsetX}%`;
        piece.element.style.top = `${topPercent + offsetY}%`;
    }
    
    // Set z-index to ensure visibility
    const allPieces = document.querySelectorAll('.game-piece');
    const baseZIndex = 10;
    
    allPieces.forEach(p => p.style.zIndex = baseZIndex);
    
    if (stateIndex === 6) {
        // Make banished pieces appear on top with slight variation
        piece.element.style.zIndex = baseZIndex + 20 + Math.floor(Math.random() * 5);
    } else {
        const piecesInState = getPiecesInState(stateIndex);
        
        // Sort pieces by player for better stacking
        const sortedPieces = [...piecesInState].sort((a, b) => {
            const aPlayerIndex = players.findIndex(player => player.pieces.includes(a));
            const bPlayerIndex = players.findIndex(player => player.pieces.includes(b));
            return aPlayerIndex - bPlayerIndex;
        });
        
        // Assign z-index with slight offset for better visibility
        sortedPieces.forEach((p, idx) => {
            p.element.style.zIndex = baseZIndex + idx + 1;
        });
        
        // Ensure current piece is visible
        piece.element.style.zIndex = baseZIndex + piecesInState.length + 1;
    }
    
    // Add a subtle animation effect
    piece.element.style.transform = 'scale(1.1)';
    setTimeout(() => piece.element.style.transform = 'scale(1)', 300);
}

function endTurn() {
    if (banishmentInProgress) return;
    
    turnEndingInProgress = true;
    movesRemaining = 0;
    waitingForSecondRoll = false;
    checkForGameEnd();
    
    // Add stalemate detection - NEW CODE
    const activePlayers = players.filter(p => p.eliminatedPieces < 2);
    if (activePlayers.length === 2) {
        // Check if both players have exactly 2 pieces left (1 piece eliminated each)
        const bothPlayersHaveTwoPieces = activePlayers.every(p => p.eliminatedPieces === 1);
        
        if (bothPlayersHaveTwoPieces) {
            twoPlayerTurnCounter++;
            // After 6 turns (3 full rounds) with 2 players with 2 pieces each, offer draw/roll-off
            if (twoPlayerTurnCounter >= 6) {
                twoPlayerTurnCounter = 0;
                offerDrawOrRollOff();
                turnEndingInProgress = false;
                return;
            }
        } else {
            twoPlayerTurnCounter = 0; // Reset counter if conditions aren't met
        }
    } else {
        twoPlayerTurnCounter = 0;
    }
    // End of new stalemate detection code
    
    let nextPlayer = (currentPlayer + 1) % players.length;
    while (players[nextPlayer].eliminatedPieces >= 2 && nextPlayer !== currentPlayer) {
        nextPlayer = (nextPlayer + 1) % players.length;
    }
    
    currentPlayer = nextPlayer;
    updateTurnDisplay();
    updateGameStatus(`${players[currentPlayer].name}'s turn - Roll the dice`);
    turnEndingInProgress = false;
    
    if (players[currentPlayer].isComputer) {
        setTimeout(() => {
            if (!banishmentInProgress && !turnEndingInProgress) handleGameDiceRoll();
        }, 1500);
    }
}

function highlightValidMoves() {
    document.querySelectorAll('.state-marker').forEach(marker => {
        marker.classList.remove('valid-move');
        if (movesRemaining > 0) {
            const stateIndex = parseInt(marker.dataset.state);
            if (stateIndex !== 6) {
                const player = players[currentPlayer];
                const hasValidMove = player.pieces.some(p => 
                    p.isOnBoard && (p.position + 1) % 6 === stateIndex
                );
                if (hasValidMove) marker.classList.add('valid-move');
            }
        }
    });
}

function makeComputerMove() {
    if (movesRemaining <= 0 || banishmentInProgress || turnEndingInProgress) return;

    const computer = players[currentPlayer];
    const validMoves = [];
    const gameAnalysis = analyzeGameState(computer);

    computer.pieces.forEach(piece => {
        if (piece.isOnBoard) {
            const targetState = (piece.position + 1) % 6;
            const moveValue = calculateMoveValue(piece, targetState, gameAnalysis);
            validMoves.push({ piece, targetState, value: moveValue });
        }
    });

    if (validMoves.length > 0) {
        validMoves.sort((a, b) => b.value - a.value);
        const useRandomMove = Math.random() < 0.2;
        const moveIndex = useRandomMove ? Math.floor(Math.random() * validMoves.length) : 0;
        const move = validMoves[moveIndex];
        
        movePieceToState(move.piece, move.targetState);
        move.piece.position = move.targetState;
        movesRemaining--;
        
        updateGameStatus(`Computer: ${movesRemaining} moves remaining`);
        highlightValidMoves();
       
        if (movesRemaining === 0) {
            if (waitingForSecondRoll) {
                handleSecondRoll();
                setTimeout(() => {
                    if (!banishmentInProgress && !turnEndingInProgress) handleGameDiceRoll();
                }, 1000);
            } else {
                const banishmentsFound = checkForBanishment();
                if (!banishmentsFound && !banishmentInProgress) {
                    setTimeout(() => {
                        if (!banishmentInProgress && !turnEndingInProgress) endTurn();
                    }, 500);
                }
                return;
            }
        } else {
            setTimeout(makeComputerMove, 1000);
        }
    }
}

function analyzeGameState(computerPlayer) {
    const analysis = {
        stateOccupancy: Array(7).fill().map(() => []),
        dangerStates: [],
        opportunityStates: [],
        playerStrength: {}
    };
    
    players.forEach((player, playerIndex) => {
        player.pieces.forEach(piece => {
            if (piece.isOnBoard && piece.position >= 0) {
                analysis.stateOccupancy[piece.position].push({
                    piece: piece,
                    playerIndex: playerIndex
                });
            }
        });
        analysis.playerStrength[playerIndex] = player.piecesInPlay - player.eliminatedPieces;
    });
    
    const computerIndex = players.findIndex(p => p === computerPlayer);
    for (let stateIndex = 0; stateIndex < 6; stateIndex++) {
        const piecesInState = analysis.stateOccupancy[stateIndex];
        const playerCounts = new Map();
        
        piecesInState.forEach(entry => {
            if (!playerCounts.has(entry.playerIndex)) playerCounts.set(entry.playerIndex, []);
            playerCounts.get(entry.playerIndex).push(entry.piece);
        });
        
        const computerPieces = playerCounts.get(computerIndex) || [];
        if (computerPieces.length === 1) {
            let isDangerous = false;
            playerCounts.forEach((pieces, playerIdx) => {
                if (playerIdx !== computerIndex && pieces.length >= 2) isDangerous = true;
            });
            if (isDangerous) analysis.dangerStates.push(stateIndex);
        }
        
        if (computerPieces.length >= 2) {
            playerCounts.forEach((pieces, playerIdx) => {
                if (playerIdx !== computerIndex && pieces.length === 1) {
                    analysis.opportunityStates.push({
                        state: stateIndex,
                        targetPlayer: playerIdx
                    });
                }
            });
        }
    }
    
    return analysis;
}

function calculateMoveValue(piece, targetState, analysis) {
    let value = 100;
    const computerIndex = players.findIndex(p => p.pieces.includes(piece));
    
    if (analysis.dangerStates.includes(piece.position)) value += 500;
    
    const computerPiecesInTarget = analysis.stateOccupancy[targetState].filter(
        entry => entry.playerIndex === computerIndex
    );
    
    if (computerPiecesInTarget.length === 1) {
        const vulnerablePlayers = analysis.stateOccupancy[targetState].filter(
            entry => entry.playerIndex !== computerIndex && 
            analysis.stateOccupancy[targetState].filter(e => e.playerIndex === entry.playerIndex).length === 1
        );
        
        if (vulnerablePlayers.length > 0) {
            value += 400;
            const targetPlayerIndex = vulnerablePlayers[0].playerIndex;
            if (analysis.playerStrength[targetPlayerIndex] < analysis.playerStrength[computerIndex]) {
                value += 100;
            }
        }
    }
    
    const piecesInCurrentState = analysis.stateOccupancy[piece.position];
    const computerPiecesInCurrent = piecesInCurrentState.filter(
        entry => entry.playerIndex === computerIndex
    );
    
    if (computerPiecesInCurrent.length === 2) {
        const otherPlayersInState = piecesInCurrentState.filter(
            entry => entry.playerIndex !== computerIndex
        );
        
        const playerCounts = new Map();
        otherPlayersInState.forEach(entry => {
            if (!playerCounts.has(entry.playerIndex)) playerCounts.set(entry.playerIndex, 0);
            playerCounts.set(entry.playerIndex, playerCounts.get(entry.playerIndex) + 1);
        });
        
        let isDangerous = false;
        playerCounts.forEach((count) => { if (count >= 2) isDangerous = true; });
        
        if (isDangerous) value -= 300;
    }
    
    if (computerPiecesInTarget.length > 0) value += 150;
    value += Math.floor(Math.random() * 50);
    
    return value;

}
function processBanishments(banishments) {
  let currentBanishmentIndex = 0;
  banishmentInProgress = true;

  function processNextBanishment() {
    if (currentBanishmentIndex < banishments.length) {
      const banishment = banishments[currentBanishmentIndex];
      
      if (banishment.piece.isOnBoard && 
          banishment.piece.position !== 6 && 
          players[banishment.victimId].eliminatedPieces < 2) {
        
        RollOffController.startBanishment(
          banishment.piece, 
          banishment.captorId, 
          banishment.victimId, 
          () => {
            setTimeout(() => {
              currentBanishmentIndex++;
              processNextBanishment();
            }, 1000);
          }
        );
      } else {
        currentBanishmentIndex++;
        setTimeout(processNextBanishment, 100);
      }
    } else {
      setTimeout(() => {
        banishmentInProgress = false;
        if (movesRemaining === 0 && !waitingForSecondRoll) {
          setTimeout(() => endTurn(), 500);
        } else {
          updateGameStatus(`${players[currentPlayer].name}'s turn`);
        }
      }, 1000);
    }
  }
  
  processNextBanishment();
}

function checkForBanishment() {
    if (banishmentInProgress) return false;
    
    const banishments = [];
    
    for (let stateIndex = 0; stateIndex < 6; stateIndex++) {
        const piecesInState = getPiecesInState(stateIndex);
        const playerCounts = new Map();
        
        piecesInState.forEach(piece => {
            const playerIndex = players.findIndex(player => player.pieces.includes(piece));
            if (!playerCounts.has(playerIndex)) playerCounts.set(playerIndex, []);
            playerCounts.get(playerIndex).push(piece);
        });
        
        playerCounts.forEach((pieces, captorId) => {
            if (pieces.length >= 2) {
                playerCounts.forEach((victimPieces, victimId) => {
                    if (captorId !== victimId && victimPieces.length === 1) {
                        banishments.push({
                            piece: victimPieces[0],
                            captorId: captorId,
                            victimId: victimId
                        });
                    }
                });
            }
        });
    }
    
    if (banishments.length > 0) {
        banishmentInProgress = true;
        processBanishments(banishments);
        return true;
    }
    
    return false;
}

function getPiecesInState(stateIndex) {
    const pieces = [];
    players.forEach(player => {
        player.pieces.forEach(piece => {
            if (piece.position === stateIndex && piece.isOnBoard) {
                pieces.push(piece);
            }
        });
    });
    return pieces;
}

function updateGameStatus(message) {
    document.getElementById('gameStatus').textContent = message;
}

function updateTurnDisplay() {
    const panel = document.getElementById('playerTurnPanel');
    panel.innerHTML = '';
    
    const teamColors = {
        1: { background: '#ff9a9a', border: '#e74c3c' },
        2: { background: '#8cc7f0', border: '#2980b9' },
        3: { background: '#7aeb9c', border: '#27ae60' }
    };
    
    players.forEach((player, index) => {
        const item = document.createElement('div');
        
        if (player.eliminatedPieces >= 2) {
            item.className = 'player-turn-item eliminated';
            item.innerHTML = `
                <span class="player-emoji" style="
                    background-color: ${teamColors[player.team].background}; 
                    border: 2px solid ${teamColors[player.team].border};
                    opacity: 0.5;
                    width: 30px; 
                    height: 30px; 
                    border-radius: 50%; 
                    display: flex; 
                    align-items: center; 
                    justify-content: center;
                    box-shadow: 0 0 3px rgba(0,0,0,0.3);
                    text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
                    font-weight: bold;
                ">${player.emoji}</span>
                <span class="player-name">${player.name} (Eliminated)</span>
            `;
        } else {
            item.className = `player-turn-item ${index === currentPlayer ? 'active' : ''}`;
            item.innerHTML = `
                <span class="player-emoji" style="
                    background-color: ${teamColors[player.team].background}; 
                    border: 2px solid ${teamColors[player.team].border};
                    width: 30px; 
                    height: 30px; 
                    border-radius: 50%; 
                    display: flex; 
                    align-items: center; 
                    justify-content: center;
                    box-shadow: 0 0 3px rgba(0,0,0,0.3);
                    text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
                    font-weight: bold;
                ">${player.emoji}</span>
                <span class="player-name">${player.name}</span>
            `;
        }
        panel.appendChild(item);
    });
}

function getStateName(stateIndex) {
    const states = ["Victoria", "New South Wales", "Queensland", "Northern Territory", "Western Australia", "South Australia", "Tasmania"];
    return states[stateIndex];
}

function eliminatePlayer(playerIndex) {
    // Count actual pieces on board
    const actualPiecesOnBoard = players[playerIndex].pieces.filter(p => p.isOnBoard).length;
    
    // Only eliminate if player truly has 0 or 1 pieces left
    if (actualPiecesOnBoard > 1) {
        console.log(`Not eliminating player ${playerIndex} - they still have ${actualPiecesOnBoard} pieces on board`);
        return;
    }
    
    players[playerIndex].pieces.forEach(piece => {
        if (piece.isOnBoard) {
            piece.isOnBoard = false;
            piece.position = -1;
            piece.element.style.display = 'none';
        }
    });
    
    players[playerIndex].eliminatedPieces = 3;
    players[playerIndex].piecesInPlay = 0;
    
    showGameNotification(`${players[playerIndex].name} has been eliminated!`, 3000);
    updateTurnDisplay();
    checkForGameEnd();
}
function checkForGameEnd() {
    // If game already ended, don't show another winner
    if (gameEnded) return;
    
    const activePlayers = players.filter(p => p.eliminatedPieces < 2);
    if (activePlayers.length === 1) {
        // Set game ended flag
        gameEnded = true;
        
        // Clear any pending computer moves
        if (computerMoveTimeout) {
            clearTimeout(computerMoveTimeout);
            computerMoveTimeout = null;
        }
        
        // Disable all game controls
        document.getElementById('rollButton').disabled = true;
        document.querySelectorAll('.state-marker').forEach(marker => {
            marker.onclick = null;
        });
        
        const winner = activePlayers[0];
        
        // Your existing winner announcement code
        const content = `
            <h2>üèÜ WINNER! üèÜ</h2>
            <div class="winner-animation">
                <span class="winner-emoji" style="
                    font-size: 80px;
                    text-shadow: 2px 2px 8px rgba(0,0,0,0.3);
                    display: inline-block;
                    animation: winnerPulse 2s infinite;
                ">${winner.emoji}</span>
            </div>
            <h3>${winner.name} has won the game!</h3>
            <p>All other players have been eliminated.</p>
            <button id="playAgainButton" style="
                background: #e67e22;
                color: white;
                border: none;
                padding: 12px 30px;
                border-radius: 5px;
                font-size: 18px;
                cursor: pointer;
                margin-top: 20px;
                transition: all 0.3s ease;
            ">Play Again</button>
        `;
        
        const notification = showNotification(content, 0);
        notification.querySelector('#playAgainButton').onclick = restartGame;
    }
}


function startRollOff() {
    const p1Name = document.getElementById('player1Name').value.trim();
    const p2Name = document.getElementById('player2Name').value.trim();
    const p3Name = document.getElementById('player3Name').value.trim();

    // Check for single player vs computer mode with custom name
    if (p1Name && !p2Name && p3Name && p3Name.toLowerCase().startsWith('game')) {
        // Check if there's a custom name after "game-"
        let computerName = 'Computer';
        if (p3Name.toLowerCase().startsWith('game-') && p3Name.length > 5) {
            computerName = p3Name.substring(5); // Extract name after "game-"
        }
        
        players = [
            {
                name: p1Name,
                pieces: [],
                roll: 0,
                team: null,
                emoji: null,
                piecesInPlay: 0,
                eliminatedPieces: 0
            },
            {
                name: computerName,
                pieces: [],
                roll: 0,
                team: null,
                emoji: null,
                piecesInPlay: 0,
                eliminatedPieces: 0,
                isComputer: true
            }
        ];
    }
    // Original multiplayer check
    else if (!p1Name || !p2Name) {
        alert('For multiplayer: Enter at least 2 player names\nFor single player: Enter your name and type "game" in Player 3');
        return;
    }
    // Original multiplayer setup
    else {
        players = [
            {
                name: p1Name,
                pieces: [],
                roll: 0,
                team: null,
                emoji: null,
                piecesInPlay: 0,
                eliminatedPieces: 0
            },
            {
                name: p2Name,
                pieces: [],
                roll: 0,
                team: null,
                emoji: null,
                piecesInPlay: 0,
                eliminatedPieces: 0
            }
        ];

        if (p3Name) {
            // Check if third player should be computer with custom name
            let isGameOpponent = p3Name.toLowerCase() === 'game';
            let computerName = 'Computer';
            
            if (p3Name.toLowerCase().startsWith('game-') && p3Name.length > 5) {
                isGameOpponent = true;
                computerName = p3Name.substring(5); // Extract name after "game-"
            }
            
            players.push({
                name: isGameOpponent ? computerName : p3Name,
                pieces: [],
                roll: 0,
                team: null,
                emoji: null,
                piecesInPlay: 0,
                eliminatedPieces: 0,
                isComputer: isGameOpponent
            });
        }
    }

    currentPlayer = 0;
    rollOffAttempts = 0;
    originalPlayers = [...players];
    
    document.getElementById('setupScreen').style.display = 'none';
    document.getElementById('rollOffScreen').style.display = 'flex';
    updateRollOffStatus(`${players[0].name} - Roll for turn order!`);
}

// === DRAW AND FINAL ROLL-OFF FUNCTIONS ===
function offerDrawOrRollOff() {
    const content = `
        <h2>Stalemate Detected</h2>
        <p>This game seems to be at a stalemate. Would you like to:</p>
        <button id="continuePlayingButton">Continue Playing</button>
        <button id="acceptDrawButton">Accept Draw</button>
        <button id="finalRollOffButton">Decide by Roll-Off</button>
    `;
    
    const notification = showNotification(content, 0);
    
    notification.querySelector('#continuePlayingButton').onclick = function() {
        notification.remove();
        endTurn();
    };
    
    notification.querySelector('#acceptDrawButton').onclick = function() {
        notification.remove();
        declareDraw();
    };
    
    notification.querySelector('#finalRollOffButton').onclick = function() {
        notification.remove();
        startFinalRollOff();
    };
}

function declareDraw() {
    const content = `
        <h2>Game Drawn!</h2>
        <p>Players have agreed to a draw.</p>
        <button id="playAgainButton">Play Again</button>
    `;
    
    const notification = showNotification(content, 0);
    
    setTimeout(function() {
        const playAgainButton = notification.querySelector('#playAgainButton');
        if (playAgainButton) {
            playAgainButton.addEventListener('click', function() {
                restartGame();
            });
        }
    }, 100);
}

function startFinalRollOff() {
    const activePlayers = players.filter(p => p.eliminatedPieces < 2);
    
    const content = `
        <h2>Final Roll-Off!</h2>
        <p>${activePlayers[0].name} and ${activePlayers[1].name} will roll to determine the winner.</p>
        <p>Highest roll wins!</p>
        <button id="startFinalRollButton">Start Roll-Off</button>
    `;
    
    const notification = showNotification(content, 0);
    
    notification.querySelector('#startFinalRollButton').onclick = function() {
        notification.remove();
        handleFinalRollOff(activePlayers[0], activePlayers[1]);
    };
}

function handleFinalRollOff(player1, player2) {
    updateGameStatus(`FINAL ROLL-OFF: ${player1.name} to roll`);
    
    const rollButton = document.getElementById('rollButton');
    const originalRollFunction = rollButton.onclick;
    
    if (player1.isComputer) {
        setTimeout(() => computerFinalRoll(player1, player2, null, originalRollFunction), 1000);
    } else {
        rollButton.onclick = () => playerFinalRoll(player1, player2, null, originalRollFunction);
    }
}

function computerFinalRoll(currentRoller, otherPlayer, previousRoll, originalRollFunction) {
    const roll = Math.floor(Math.random() * 6) + 1;
    const dice = document.getElementById('gameDice');
    dice.textContent = ['‚öÄ','‚öÅ','‚öÇ','‚öÉ','‚öÑ','‚öÖ'][roll-1];
    
    showGameNotification(`${currentRoller.name} rolled ${roll}`, 2000);
    
    if (previousRoll === null) {
        updateGameStatus(`FINAL ROLL-OFF: ${otherPlayer.name} to roll`);
        
        if (otherPlayer.isComputer) {
            setTimeout(() => computerFinalRoll(otherPlayer, currentRoller, roll, originalRollFunction), 1000);
        } else {
            const rollButton = document.getElementById('rollButton');
            rollButton.onclick = () => playerFinalRoll(otherPlayer, currentRoller, roll, originalRollFunction);
        }
    } else {
        setTimeout(() => {
            resolveFinalRollOff(otherPlayer, currentRoller, previousRoll, roll, originalRollFunction);
        }, 1000);
    }
}

function playerFinalRoll(currentRoller, otherPlayer, previousRoll, originalRollFunction) {
    const roll = Math.floor(Math.random() * 6) + 1;
    const dice = document.getElementById('gameDice');
    dice.textContent = ['‚öÄ','‚öÅ','‚öÇ','‚öÉ','‚öÑ','‚öÖ'][roll-1];
    
    showGameNotification(`${currentRoller.name} rolled ${roll}`, 2000);
    
    if (previousRoll === null) {
        updateGameStatus(`FINAL ROLL-OFF: ${otherPlayer.name} to roll`);
        
        if (otherPlayer.isComputer) {
            setTimeout(() => computerFinalRoll(otherPlayer, currentRoller, roll, originalRollFunction), 1000);
        } else {
            const rollButton = document.getElementById('rollButton');
            rollButton.onclick = () => playerFinalRoll(otherPlayer, currentRoller, roll, originalRollFunction);
        }
    } else {
        resolveFinalRollOff(otherPlayer, currentRoller, previousRoll, roll, originalRollFunction);
    }
}

function resolveFinalRollOff(player1, player2, roll1, roll2, originalRollFunction) {
    if (roll1 === roll2) {
        showGameNotification("Tie! Roll again!", 2000);
        handleFinalRollOff(player1, player2);
    } else {
        const winner = roll1 > roll2 ? player1 : player2;
        
        const content = `
            <h2>üèÜ WINNER! üèÜ</h2>
            <div class="winner-animation">
                <span class="winner-emoji" style="
                    font-size: 80px;
                    text-shadow: 2px 2px 8px rgba(0,0,0,0.3);
                    display: inline-block;
                    animation: winnerPulse 2s infinite;
                ">${winner.emoji}</span>
            </div>
            <h3>${winner.name} has won the game!</h3>
            <p>Victory by final roll-off!</p>
            <button id="playAgainButton" style="
                background: #e67e22;
                color: white;
                border: none;
                padding: 12px 30px;
                border-radius: 5px;
                font-size: 18px;
                cursor: pointer;
                margin-top: 20px;
                transition: all 0.3s ease;
            ">Play Again</button>
        `;
        
        const notification = showNotification(content, 0);
        notification.querySelector('#playAgainButton').onclick = restartGame;
    }
}
</script>
</body>
</html>